\chapter{Funzioni della famiglia apply}
\section{Scopo}

Molto spesso nelle pratiche applicazioni  al fine di condurre nel migliore dei modi la nostra analisi si rende necessario applicare una stessa funzione a una serie di elementi.

Il modo principale per ottenere ciò è attraverso la creazione di un apposito loop (una ripetizione consecutiva un numero di volte) con i costrutti di \erre\ a questo scopo preposti come \textsf{for}, \textsf{if}, eccetera.

Spesso però, con operazioni abbastanza frequenti (come la somma di tutti i valori di una colonna ad esempio) lo stesso risultato si può ottenere con una famiglia di funzioni appositamente costruita per sfruttare le caratteristiche proprie degli oggetti a cui si applicano ed ottenere lo stesso risultato di un loop ma con meno codice.

Queste funzioni appartengo alla cosiddetta famiglia \textsf{apply}.

\section{apply}
La prima di queste funzioni è \textsf{apply}. Questa funzione opera in maniera molto semplice permettendo con poco codice di applicare un'altra funzione, da specificare all'interno di \textsf{apply}, su una dimensione di un oggetto array e quindi anche sulla forma più basilare di array, un array bidimensionale o più volgarmente, una matrice.

Nella esecuzione non è più veloce di un loop (lo era nelle prime versioni del linguaggio \textsf{S}), è però molto più pratica in quanto come si è detto, richiede molto meno codice.

La sintassi è la seguente:
\begin{lstlisting}
apply(<array>, <dimensione>, <funzione>)
\end{lstlisting}

Dove con array abbiamo un oggetto ti tipo array anche multidimensionale ma anche un data frame, con funzione abbiamo il nome e soltanto il nome di una funzione da applicare e con dimensione abbiamo una delle dimensioni dell'oggetto.

La particolarità da ricordare onde evitare di incorrere in errori, è che l'oggetto \textsf{<funzione>} all'interno di \textsf{lapply} va inserito senza alcuna parentesi. In pratica va scritto solo il nome della funzione usata. Ad esempio se vogliamo la media, dobbiamo usare la funzione \textsf{mean} e scrivere solo il nome di quest'ultima.

Fondamentale è anche capire il concetto di dimensione. Banalmente una matrice (che è un array bidimensionale), ha appunto due dimensioni: righe e colonne. Ne consegue che quindi specificando 1 la funzione \textsf{<funzione>} all'interno di \textsf{<array>} sarà applicata alle righe mentre con 2 sarà applicata alle colonne.

Vediamo un esempio in cui creiamo un data frame usando due vettori di valori e successivamente applichiamo a quest'ultimo la funzione \textsf{sd} al fine di trovare la deviazione standard di ogni colonna.
\begin{lstlisting}
> valori1 <- c(1:5)
> valori1
[1] 1 2 3 4 5
> valori2 <- c(10:15)
> valori2
[1] 10 11 12 13 14
>
> dataF <- data.frame(valori1, valori2)
> dataF
  valori1 valori2
1       1      10
2       2      11
3       3      12
4       4      13
5       5      14
> apply(dataF, 2, sd)
 valori1  valori2 
1.581139 1.581139 
\end{lstlisting}

Alcune considerazioni sull'esempio precedente:
\begin{itemize}
\item la funzione \textsf{apply} si applica a data frame e array ed ha come output una lvettore di elementi; come si vedrà non sempre l'output è un oggetto vettore.
\item è stato utilizzato l'operatore \textsf{colon} dato dai due puntini \textsf{< : >} per creare una sequenza di numeri da 1 a 5 e da 10 a 14, quindi per ottenere due vettori di 5 elementi.
\item la lunghezza dei vettori da unire nel data frame deve essere uguale altrimenti \erre\ avrebbe restituito un errore.
\item il numero 2 usato come secondo elemento della funzione \textsf{apply} sta ad indicare la seconda dimensione del nostro oggetto e cioè le colonne. Sarebbe stato possibile calcolare la deviazione standard per ogni riga specificando la dimensione 1 e cioè righe.
\end{itemize}


\section{lapply e sapply}

La seconda di queste funzioni è \textsf{lapply}\footnote{È una funzione definita internamente in C.}, diminutivo di list apply. L'idea alla base di questa funzione è che data una lista di oggetti \textsf{lapply} applica una determinata funzione a tutti gli elementi di quella lista, quindi ad ogni singolo oggetto.

Questo oltre ad essere molto utile per oggetti che sono liste in senso stretto ha anche altre implicazioni. A ben ricordare un data frame non è altro che una list composta da vettori di eguali dimensioni.

La funzione lapply quindi prende ogni colonna del data frame, che in realtà non è altro che un elemento vettore a sua volta parte del data frame che è una list, e vi applica una specifica funzione. Ne consegue che è come se avessimo creato un loop per tutte le colonne (ma anche le righe) di un data frame.

La sintassi è molto semplice:
\begin{lstlisting}
lapply(<dataframe>, <funzione>)
\end{lstlisting}

Ecco un esempio in cui creiamo un data frame usando due vettori di valori e successivamente applichiamo a quest'ultimo la funzione \textsf{sd} al fine di trovare la deviazione standard di ogni colonna.

\begin{lstlisting}
> dataF
  valori1 valori2
1       1      10
2       2      11
3       3      12
4       4      13
5       5      14
>
> lapply(dataF, sd)
$valori1
[1] 1.581139

$valori2
[1] 1.581139
\end{lstlisting}

Come già detto, con \textsf{lapply} si ottiene come output un oggetto di classe list. Ciò a volte potrebbe non essere desiderabile e per ottenere un oggetto di tipo vettore, in \erre\ è implementata un'altra funzione che lavora esattamente come \textsf{lapply} ma semplifica il risultato offrendo come output un vettore. Questa funzione è \textsf{sapply}, che sta per simplified lapply.

Ecco un esempio usando il data frame creato in precedenza.

\begin{lstlisting}
> sapply(dataF, sd)
 valori1  valori2 
1.581139 1.581139 
\end{lstlisting}

Questa funzione opera dietro le quinte una semplificazione del risultato ottenuto, ma per far ciò deve cercare in qualche modo di capire quale potrebbe essere un risultato semplificato.

Questo processo che \textsf{sapply} esegue in background, con basi di dati di grosse dimensioni potrebbe essere abbastanza lento per i normali tempi di esecuzione e a volte anche per l'utente che potrebbe avvertire il lungo tempo di esecuzione.

Per ovviare a ciò potrebbe essere utile usare la funzione \textsf{vapply} che richiede un terzo argomento obbligatorio che indica il formato di output desiderato. In questo modo la computazione è molto più veloce perché la funzione sa già cosa deve restituite. Tuttavia \erre\ fa esattamente ciò che l'utente dice di fare a meno che non si tratti di qualcosa di impossibile, è bene quindi prestare attenzione a non richiedere un formato di output impossibile per i dati che \textsf{vapply} deve processare.

\section{tapply}
La funzione \textsf{tapply} è usata per applicare una funzione su sottoinsiemi di un oggetto matrice o data frame o array, divisi secondo particolari istruzioni definite da un altro sottoinsieme dello stesso oggetto\footnote{Ma anche di altri in effetti.}. 

Immaginiamo di avere un vettore numerico e di voler applicare una funzione a sottoinsiemi di questo vettore basati su alcuni caratteristiche definite da un altro vettore (che quasi sempre è un factor). In pratica \textsf{tapply} divide un vettore in pezzi più piccoli ed applica la funzione ad ognuno di questi.

È molto utile vedere un esempio. Supponiamo di misurare per un gruppo di sei persone, il loro sesso e il loro reddito. Al fine di condurre una ricerca su una eventuale differenza di reddito tra uomini e donne sarebbe utile con i nostri dati calcolare la media del reddito per ogni gruppo: uomini e donne.

Per prima cosa creiamo un data base e successivamente usiamo la funzione
\textsf{tapply} per applicare la funzione \textsf{mean} (media), sulla colonna reddito suddivisa però sulla base dei due livelli presenti nella colonna genere, quindi per sesso maschile e femminile.

\begin{lstlisting}
> d <- data.frame( list( genere = c("M","M","F","M","F","F"), 
reddito = c(55000,88000,32450,76500,123000,45650) ) )
> d
  genere reddito
1      M   55000
2      M   88000
3      F   32450
4      M   76500
5      F  123000
6      F   45650
> tapply(d$reddito, d$genere, mean)
       F        M 
67033.33 73166.67
\end{lstlisting}

L'output è composto dalle due medie della colonna reddito, una calcolata sulla base del fattore M e l'altra sulla base del fattore F.

\subsection{split}

Come abbiamo visto, \textsf{tapply} divide l'oggetto in gruppi ai quali applica separatamente una data funzione invocata dall'utente. La funzione \textsf{split} sostanzialmente si ferma al primo passo.

La funzione \textsf{split} divide un oggetto \erre\ sulla base delle indicazioni dell'utente e ha come output un oggetto list.

Nell'esempio sottostante si utilizza il data frame precedente, per ottenere due data frame entrambi elementi di un oggetto di livello superiore di class list.

\begin{lstlisting}	
> d1 <- split(d, d$genere)
> d1
$F
  genere reddito
3      F   32450
5      F  123000
6      F   45650

$M
  genere reddito
1      M   55000
2      M   88000
4      M   76500
\end{lstlisting}

\section{mapply}

Da un punto di vista concettuale \textsf{mapply} potrebbe essere quella più tricky. La forza di \textsf{mapply} sta nel fatto di poter essere applicata ad elementi multipli. Il funzionamento è il seguente: dati due (o più) oggetti \erre, ad esempio due vettori di uguale lunghezza, \textsf{mapply} estrae il primo elemento di ognuno e vi applica la funziona specificata, dopodiché estrae il secondo elemento di ogni oggetto e vi applica la funzione, dopodiché estrae il terzo elemento di ogni oggetto e vi applica la funzione\dots\ e così via fino a che tutti gli elementi di tutti gli oggetti non sono stati trattati.

Come al solito un esempio può essere chiarificatore.

Supponiamo di avere due vettori p1 e p2 e di voler sommare il primo elemento di p1 con il primo di p2, il secondo di p1 con il secondo di p2 ecc.

\begin{lstlisting}
> p1 <- c(1:5)
> p2 <- c(10:14)
> mapply( "+" , p1, p2)
[1] 11 13 15 17 19
\end{lstlisting}

Considerazioni sull'esempio:
\begin{itemize}
\item l'esempio è volutamente banale; lo stesso risultato si sarebbe potuto avere semplicemente con \textsf{> p1 + p2}, alcuni esempi più complessi si avranno nei successivi paragrafi. 
\item si noti l'uso delle virgolette nello specificare la funzione somma.
\item il semplice operatore di addizione, il simbolo ``+'', è in realtà una funzione.
\end{itemize}

\subsection{Introduzione alle anonymous functions}

Al fine di meglio comprendere la funzione \textsf{mapply} fornendo esempi più complessi, si introducono brevemente le anonymous functions molto usate dalle funzioni della famiglia \textsf{apply}. Le anonymous functions sono funzioni che non hanno un nome perché definite solo all'interno della funzione (\textsf{mapply}, ma anche \textsf{apply}, \textsf{sapply} ed altre) che di esse si serve ed usate solo al suo interno. Una volta eseguite, sostanzialmente spariscono.

Un esempio semplice è rappresentato dal seguente codice che sostanzialmente istruisce \erre\ su una funzione composta da due argomenti x ed y che restituisce come output un valore dato dalla potenza del primo, x, elevato alla seconda, y.

\begin{lstlisting}
function(x,y) x^y
\end{lstlisting}


\subsection{mapply: esempi con le anonymous functions}

Ora che brevemente sono state introdotte le anonymous functions è possibile sfruttarle per costruire qualche esempio più complesso su come utilizzare la funzione \textsf{mapply}.

Supponiamo di avere tre vettori di eguale lunghezza 
\begin{lstlisting}
> p1 <- c(1:5)
> p2 <- c(10:14)
> p3 <- c(-1, 1, -1, 2, 1)
\end{lstlisting}

Usiamo questi vettori e la funzione \textsf{mapply} per ottenere quel valore dato dalla quoziente avente al numeratore il prodotto del primo elemento di p1, moltiplicato il primo elemento di p2 e come denominatore il primo elemento di p3.

\begin{lstlisting}
> mapply( function(x, y, z) (x*y)/z , p1, p2, p3)
[1] -10  22 -36  26  70
\end{lstlisting}

Una simile funzione in \erre\ non esiste ecco perché si è reso necessario definirla all'interno della funzione \textsf{mapply}.

Un altro esempio illustrativo potrebbe essere il seguente che fa uso della funzione \textsf{rep(<valore>, <volte>)}, che sostanzialmente ripete il <valore> un numero di <volte>.
\begin{lstlisting}
> mapply( function(x,y,z){ rep(y, x) * z } , p1, p2, p3)
[[1]]
[1] -10

[[2]]
[1] 11 11

[[3]]
[1] -12 -12 -12

[[4]]
[1] 26 26 26 26

[[5]]
[1] 14 14 14 14 14
\end{lstlisting}

Come prima la funzione anonima function ha tre elementi. Essa è istruita per prendere il primo elemento di p1, ripeterlo un numero di volte pari al numero del primo elemento p2 e moltiplicare questo output per il primo elemento di p3. Così per tutti gli elementi i-esimi dei tre vettori di eguale lunghezza.

