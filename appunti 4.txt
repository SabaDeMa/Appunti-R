
str

questa funzione in pratica ha come obiettivo quello di mostrare la struttura
interna di un oggetto in R, per vedere cosa è e cosa c'è.
La domanda principale è cosa c'è nell'oggetto?	



\section(SIMULATION)

CI sono diverse funzioni per simulare numeri o variabili partendo da distribuzioni
di probabilità.

rnorm() simula da una Normale data la media e la deviazione standard

dnorm() 

rpois() genera numeri/ variabili pseudo casuali da una Poisson con un dato rate

Per ogni distribuzione di probabilità ci sono una serie di funzioni per estrapolare la densità, per generare variabili in modo pseudo casuali, per trovare la distribuzione cumulativa, e per in quantili.
Ognuna di queste funzioni inizia con d per density, r for random, p per cumulative, q for quantile.

Quindi per una funzione di densità gamma ci saranno le funzioni dramma, rgamma, ecc per una poisson ci saranno le dpois, rpois ecc

Quando si genera un qualsiasi numero è importante usare set.seed(1) per impostare il seme di partenza della generazione, così quando ripeto la generazione il campione pseudo casuale sarà lo stesso. Questo è importante per avere esperimenti riproducibili. Il comando set.seed() va impostato ogni volta che si generano numeri.

\section{SIMULATE A LINEAR MODEL}

\section{R PROFILER}

Aiuta a capire perché ad esempio una funzione o una certa operazione sta impiegando
molto tempo o più del tempo che si era previsto, ed aiuta a capire dove sta il problema


Il profiler è un modo sistematico di analizzare quanto tempo il programma sta impiegando
in ogni parte del programma (molto utile per ottimizzarlo)

Spesso il codice funziona ma cosa succede se il codice funzionante diventa parte,
molto piccola, di una funzione o un programma molto più grande. È utile capire cosa
succederebbe dopo ad esempio 1000 iterazione.


Profiling è meglio che cercare di indovinare.

Ottimizzazione del codice, con ottima citazioni di Donald Knuth. È importante capire in che parte del programma viene impiegato (sprecato, molto spesso) la maggior parte del tempo.

Linee guida:

- design first, then optimize
- premature optimization is the root of all evil
- measure (collect data), don't data
- if you're going to be scientist, you need to apply the same principles here!

funzioni utili:


system.time()

prende una espressione di R come input e restituisce la quantità di tempo necessaria
per computare quella espressione.

Posso intere più espressioni o funzioni inserendo anche delle parentesi graffe

system.time({})

Misura il tempo in secondi necessari per eseguire quella operazione e se c'è un errore
restituisce il tempo impiegato fino all'errore.

Restituisce on oggetto di classe proc_time

Ci sono due valori tempo

- user time: il tempo impiegato dai processori per fare l'operazione
- elapsed time: il tempo che l'utente impiega, detto anche wall clock time,

Spesso i due valori sono molto vicini
Il tempo elapsed può essere maggiore del user time se il processore impiega molto più
tempo per "waiting around", in pratica se sta ad aspettare che le cose succedano (quindi che vengano scritti dati ecc)

elapsed time può essere più breve del user time con pc multiprocessori, cosa che però spesso non vengono usati. R spesso non li usa, ma ci sono librerie come ATLAS, ACML, MKL (per Intel), vecLib/Accelerate (per Mac) oppure il pacchetto parallel che sono strumenti ottimizzati per usare i multi core dei computer.



 \sectin{R PROFILER}

Rprof(), summaryRprof() rende un sommario dell'output di Rprof() e lo rende leggibile perché di solito Rprof() restituisce un output non propriamente leggibile.
Non usare system.time() e Rprof() insieme altrimenti so cazzi.

Rprof() sostanzialmente tiene traccia del function call stack (quindi della pila di routine che il programma deve eseguire in un determinato momento) ad intervalli regolari (generalmente di 0.02 secondi) e crea una tabella con quanto tempo ogni funzione o routine ha impiegato per essere eseguita.



\section{sample}












